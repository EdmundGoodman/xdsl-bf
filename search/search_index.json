{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>An optimising BrainF compiler in xDSL.</p>"},{"location":"reference/compiler.html","title":"Compiler","text":""},{"location":"reference/compiler.html#xdslbf.compiler","title":"<code>compiler</code>","text":"<p>Compiler for the BrainF language.</p>"},{"location":"reference/compiler.html#xdslbf.compiler.get_context","title":"<code>get_context() -&gt; Context</code>","text":"<p>Get a context with the dialects required to lower BrainF.</p> Source code in <code>src/xdslbf/compiler.py</code> <pre><code>def get_context() -&gt; Context:\n    \"\"\"Get a context with the dialects required to lower BrainF.\"\"\"\n    ctx = Context()\n    ctx.load_dialect(arith.Arith)\n    ctx.load_dialect(scf.Scf)\n    ctx.load_dialect(cf.Cf)\n    ctx.load_dialect(memref.MemRef)\n    ctx.load_dialect(func.Func)\n    ctx.load_dialect(Builtin)\n    ctx.load_dialect(bf.BrainF)\n    return ctx\n</code></pre>"},{"location":"reference/compiler.html#xdslbf.compiler.parse_brainf","title":"<code>parse_brainf(program: str) -&gt; ModuleOp</code>","text":"<p>Parse a BrainF program.</p> Source code in <code>src/xdslbf/compiler.py</code> <pre><code>def parse_brainf(program: str) -&gt; ModuleOp:\n    \"\"\"Parse a BrainF program.\"\"\"\n    return BrainFParser(Path(\"in_memory\"), program).parse()\n</code></pre>"},{"location":"reference/compiler.html#xdslbf.compiler.lower_bf_builtin","title":"<code>lower_bf_builtin(program: str, ctx: Context) -&gt; ModuleOp</code>","text":"<p>Parse a BrainF program and lower it to valid MLIR IR.</p> Source code in <code>src/xdslbf/compiler.py</code> <pre><code>def lower_bf_builtin(program: str, ctx: Context) -&gt; ModuleOp:\n    \"\"\"Parse a BrainF program and lower it to valid MLIR IR.\"\"\"\n    module = parse_brainf(program)\n    LowerBfToBuiltinPass().apply(ctx, module)\n    return module\n</code></pre>"},{"location":"reference/compiler.html#xdslbf.compiler.get_bf_from_file","title":"<code>get_bf_from_file(name: str) -&gt; str</code>","text":"<p>Get BrainF source code from a file relative to the project root.</p> Source code in <code>src/xdslbf/compiler.py</code> <pre><code>def get_bf_from_file(name: str) -&gt; str:\n    \"\"\"Get BrainF source code from a file relative to the project root.\"\"\"\n    file = Path(__file__).parent.parent.parent / name\n    return file.read_text().strip()\n</code></pre>"},{"location":"reference/compiler.html#xdslbf.compiler.compile_hanoi","title":"<code>compile_hanoi() -&gt; None</code>","text":"<p>Compile the towers of hanoi example.</p> Source code in <code>src/xdslbf/compiler.py</code> <pre><code>def compile_hanoi() -&gt; None:\n    \"\"\"Compile the towers of hanoi example.\"\"\"\n    code = get_bf_from_file(\"tests/examples/hanoi.bf\")\n    module = lower_bf_builtin(code, ctx=get_context())\n    Printer().print(module)\n</code></pre>"},{"location":"reference/compiler.html#xdslbf.compiler.interpret_hello_world","title":"<code>interpret_hello_world() -&gt; None</code>","text":"<p>Interpret a \u2018Hello world\u2019 program.</p> Source code in <code>src/xdslbf/compiler.py</code> <pre><code>def interpret_hello_world() -&gt; None:\n    \"\"\"Interpret a 'Hello world' program.\"\"\"\n    code = (\n        \"&gt;++++++++[&lt;+++++++++&gt;-]&lt;.&gt;++++[&lt;+++++++&gt;-]&lt;+.+++++++..+++.&gt;&gt;++++++\"\n        \"[&lt;+++++++&gt;-]&lt;++.------------.&gt;++++++[&lt;+++++++++&gt;-]\"\n        \"&lt;+.&lt;.+++.------.--------.&gt;&gt;&gt;++++[&lt;++++++++&gt;-]&lt;+.\"\n    )\n    module = parse_brainf(code)\n    BrainFInterpreter().interpret(module)\n</code></pre>"},{"location":"reference/dialects.html","title":"Dialects","text":""},{"location":"reference/dialects.html#xdslbf.dialects.bf","title":"<code>bf</code>","text":"<p>Dialect for BrainF\u2019s instruction set.</p> <p>From Wikipedia:</p> <ul> <li> <p>= Increment the data pointer by one (to point to the next cell to the   right).</p> </li> <li>&lt; = Decrement the data pointer by one (to point to the next cell to the left).</li> <li> <ul> <li>= Increment the byte at the data pointer by one.</li> </ul> </li> <li> <ul> <li>= Decrement the byte at the data pointer by one.</li> </ul> </li> <li>[ = If the byte at the data pointer is zero, then instead of moving the   instruction pointer forward to the next command, jump it forward to the   command after the matching ] command.</li> <li>] = If the byte at the data pointer is nonzero, then instead of moving the   instruction pointer forward to the next command, jump it back to the command   after the matching [ command.</li> <li>. = Output the byte at the data pointer.</li> <li>, = Accept one byte of input, storing its value in the byte at the data   pointer.</li> </ul>"},{"location":"reference/dialects.html#xdslbf.dialects.bf.BrainFOperation","title":"<code>BrainFOperation</code>","text":"<p>               Bases: <code>IRDLOperation</code>, <code>ABC</code></p> <p>An operation in the BrainF language.</p> Source code in <code>src/xdslbf/dialects/bf.py</code> <pre><code>class BrainFOperation(IRDLOperation, abc.ABC):\n    \"\"\"An operation in the BrainF language.\"\"\"\n</code></pre>"},{"location":"reference/dialects.html#xdslbf.dialects.bf.IncOp","title":"<code>IncOp</code>","text":"<p>               Bases: <code>BrainFOperation</code></p> <p>Increment operation <code>+</code>.</p> <p>Increment the byte at the data pointer by one.</p> Source code in <code>src/xdslbf/dialects/bf.py</code> <pre><code>@irdl_op_definition\nclass IncOp(BrainFOperation):\n    \"\"\"Increment operation `+`.\n\n    Increment the byte at the data pointer by one.\n    \"\"\"\n\n    name = \"bf.inc\"\n\n    traits = traits_def(MemoryWriteEffect())\n</code></pre>"},{"location":"reference/dialects.html#xdslbf.dialects.bf.DecOp","title":"<code>DecOp</code>","text":"<p>               Bases: <code>BrainFOperation</code></p> <p>Decrement operation <code>-</code>.</p> <p>Decrement the byte at the data pointer by one.</p> Source code in <code>src/xdslbf/dialects/bf.py</code> <pre><code>@irdl_op_definition\nclass DecOp(BrainFOperation):\n    \"\"\"Decrement operation `-`.\n\n    Decrement the byte at the data pointer by one.\n    \"\"\"\n\n    name = \"bf.dec\"\n    traits = traits_def(MemoryWriteEffect())\n</code></pre>"},{"location":"reference/dialects.html#xdslbf.dialects.bf.LshftOp","title":"<code>LshftOp</code>","text":"<p>               Bases: <code>BrainFOperation</code></p> <p>Left shift operation <code>&lt;</code>.</p> <p>Increment the data pointer by one (to point to the next cell to the right).</p> Source code in <code>src/xdslbf/dialects/bf.py</code> <pre><code>@irdl_op_definition\nclass LshftOp(BrainFOperation):\n    \"\"\"Left shift operation `&lt;`.\n\n    Increment the data pointer by one (to point to the next cell to the right).\n    \"\"\"\n\n    name = \"bf.lshft\"\n    traits = traits_def(MemoryWriteEffect())\n</code></pre>"},{"location":"reference/dialects.html#xdslbf.dialects.bf.RshftOp","title":"<code>RshftOp</code>","text":"<p>               Bases: <code>BrainFOperation</code></p> <p>Right shift operation <code>&gt;</code>.</p> <p>Decrement the data pointer by one (to point to the next cell to the left).</p> Source code in <code>src/xdslbf/dialects/bf.py</code> <pre><code>@irdl_op_definition\nclass RshftOp(BrainFOperation):\n    \"\"\"Right shift operation `&gt;`.\n\n    Decrement the data pointer by one (to point to the next cell to the left).\n    \"\"\"\n\n    name = \"bf.rshft\"\n    traits = traits_def(MemoryWriteEffect())\n</code></pre>"},{"location":"reference/dialects.html#xdslbf.dialects.bf.LoopOp","title":"<code>LoopOp</code>","text":"<p>               Bases: <code>BrainFOperation</code></p> <p>Loop start operation <code>[</code>.</p> <p>If the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching ] command.</p> Source code in <code>src/xdslbf/dialects/bf.py</code> <pre><code>@irdl_op_definition\nclass LoopOp(BrainFOperation):\n    \"\"\"Loop start operation `[`.\n\n    If the byte at the data pointer is zero, then instead of moving the\n    instruction pointer forward to the next command, jump it forward to the\n    command after the matching ] command.\n    \"\"\"\n\n    name = \"bf.loop\"\n\n    body = region_def()\n    traits = traits_def(MemoryReadEffect())\n\n    def __init__(\n        self,\n        *,\n        regions: (\n            Sequence[\n                Region\n                | None\n                | Sequence[Operation]\n                | Sequence[Block]\n                | Sequence[Region | Sequence[Operation] | Sequence[Block]]\n            ]\n            | None\n        ) = None,\n        **kwargs: Any,\n    ):\n        \"\"\"Default to a single empty region.\"\"\"\n        if regions is None:\n            regions = [Region([Block()])]\n        super().__init__(regions=regions, **kwargs)\n</code></pre>"},{"location":"reference/dialects.html#xdslbf.dialects.bf.LoopOp.__init__","title":"<code>__init__(*, regions: Sequence[Region | None | Sequence[Operation] | Sequence[Block] | Sequence[Region | Sequence[Operation] | Sequence[Block]]] | None = None, **kwargs: Any)</code>","text":"<p>Default to a single empty region.</p> Source code in <code>src/xdslbf/dialects/bf.py</code> <pre><code>def __init__(\n    self,\n    *,\n    regions: (\n        Sequence[\n            Region\n            | None\n            | Sequence[Operation]\n            | Sequence[Block]\n            | Sequence[Region | Sequence[Operation] | Sequence[Block]]\n        ]\n        | None\n    ) = None,\n    **kwargs: Any,\n):\n    \"\"\"Default to a single empty region.\"\"\"\n    if regions is None:\n        regions = [Region([Block()])]\n    super().__init__(regions=regions, **kwargs)\n</code></pre>"},{"location":"reference/dialects.html#xdslbf.dialects.bf.RetOp","title":"<code>RetOp</code>","text":"<p>               Bases: <code>BrainFOperation</code></p> <p>Loop return operation <code>]</code>.</p> <p>If the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching [ command.</p> Source code in <code>src/xdslbf/dialects/bf.py</code> <pre><code>@irdl_op_definition\nclass RetOp(BrainFOperation):\n    \"\"\"Loop return operation `]`.\n\n    If the byte at the data pointer is nonzero, then instead of moving the\n    instruction pointer forward to the next command, jump it back to the command\n    after the matching [ command.\n    \"\"\"\n\n    name = \"bf.ret\"\n    traits = traits_def(MemoryReadEffect(), IsTerminator())\n</code></pre>"},{"location":"reference/dialects.html#xdslbf.dialects.bf.OutOp","title":"<code>OutOp</code>","text":"<p>               Bases: <code>BrainFOperation</code></p> <p>Output operation <code>&lt;</code>.</p> <p>Output the byte at the data pointer.</p> Source code in <code>src/xdslbf/dialects/bf.py</code> <pre><code>@irdl_op_definition\nclass OutOp(BrainFOperation):\n    \"\"\"Output operation `&lt;`.\n\n    Output the byte at the data pointer.\n    \"\"\"\n\n    name = \"bf.out\"\n    traits = traits_def(MemoryReadEffect())\n</code></pre>"},{"location":"reference/dialects.html#xdslbf.dialects.bf.InOp","title":"<code>InOp</code>","text":"<p>               Bases: <code>BrainFOperation</code></p> <p>Input operation <code>&gt;</code>.</p> <p>Accept one byte of input, storing its value in the byte at the data pointer.</p> Source code in <code>src/xdslbf/dialects/bf.py</code> <pre><code>@irdl_op_definition\nclass InOp(BrainFOperation):\n    \"\"\"Input operation `&gt;`.\n\n    Accept one byte of input, storing its value in the byte at the data pointer.\n    \"\"\"\n\n    name = \"bf.in\"\n    traits = traits_def(MemoryWriteEffect())\n</code></pre>"},{"location":"reference/frontend.html","title":"Frontend","text":""},{"location":"reference/frontend.html#xdslbf.frontend.lexer","title":"<code>lexer</code>","text":"<p>Lexer for the BrainF language.</p>"},{"location":"reference/frontend.html#xdslbf.frontend.lexer.BrainFTokenKind","title":"<code>BrainFTokenKind</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Tokens for the BrainF language.</p> Source code in <code>src/xdslbf/frontend/lexer.py</code> <pre><code>class BrainFTokenKind(Enum):\n    \"\"\"Tokens for the BrainF language.\"\"\"\n\n    PLUS = auto()\n    MINUS = auto()\n    LT = auto()\n    GT = auto()\n    SBRACKET_OPEN = auto()\n    SBRACKET_CLOSE = auto()\n    DOT = auto()\n    COMMA = auto()\n    EOF = auto()\n</code></pre>"},{"location":"reference/frontend.html#xdslbf.frontend.lexer.BrainFLexer","title":"<code>BrainFLexer</code>","text":"<p>               Bases: <code>Lexer[BrainFTokenKind]</code></p> <p>Lexer for the BrainF language.</p> Source code in <code>src/xdslbf/frontend/lexer.py</code> <pre><code>class BrainFLexer(Lexer[BrainFTokenKind]):\n    \"\"\"Lexer for the BrainF language.\"\"\"\n\n    def _get_char(self) -&gt; str | None:\n        \"\"\"Get the character at the current location, or None if out of bounds.\"\"\"\n        res = self.input.slice(self.pos, self.pos + 1)\n        self.pos += 1\n        return res\n\n    def lex(self) -&gt; BrainFToken:\n        \"\"\"Lex the program.\"\"\"\n        if (current_char := self._get_char()) in TOKEN_LOOKUP:\n            return self._form_token(TOKEN_LOOKUP[current_char], self.pos)\n\n        raise ParseError(\n            Span(self.pos, self.pos + 1, self.input),\n            f\"Unexpected character: {current_char}\",\n        )\n</code></pre>"},{"location":"reference/frontend.html#xdslbf.frontend.lexer.BrainFLexer.lex","title":"<code>lex() -&gt; BrainFToken</code>","text":"<p>Lex the program.</p> Source code in <code>src/xdslbf/frontend/lexer.py</code> <pre><code>def lex(self) -&gt; BrainFToken:\n    \"\"\"Lex the program.\"\"\"\n    if (current_char := self._get_char()) in TOKEN_LOOKUP:\n        return self._form_token(TOKEN_LOOKUP[current_char], self.pos)\n\n    raise ParseError(\n        Span(self.pos, self.pos + 1, self.input),\n        f\"Unexpected character: {current_char}\",\n    )\n</code></pre>"},{"location":"reference/frontend.html#xdslbf.frontend.parser","title":"<code>parser</code>","text":"<p>Parser for the BrainF language.</p>"},{"location":"reference/frontend.html#xdslbf.frontend.parser.BrainFParser","title":"<code>BrainFParser</code>","text":"<p>               Bases: <code>GenericParser[BrainFTokenKind]</code></p> <p>Parser for the BrainF language.</p> Source code in <code>src/xdslbf/frontend/parser.py</code> <pre><code>class BrainFParser(GenericParser[BrainFTokenKind]):\n    \"\"\"Parser for the BrainF language.\"\"\"\n\n    def __init__(self, file: Path, program: str):\n        \"\"\"Instantiate the parser with the lexer.\"\"\"\n        super().__init__(ParserState(BrainFLexer(Input(program, str(file)))))\n\n    def parse(self) -&gt; ModuleOp:\n        \"\"\"Parse a BrainF program.\"\"\"\n        module_op = ModuleOp([])\n        scope: list[Block] = [module_op.body.block]\n\n        while True:\n            token = self._consume_token()\n            if token.kind == BrainFTokenKind.EOF:\n                break\n\n            if token.kind == BrainFTokenKind.SBRACKET_OPEN:\n                scope[-1].add_op(LoopOp(regions=[Region([block := Block([])])]))\n                scope.append(block)\n            elif token.kind == BrainFTokenKind.SBRACKET_CLOSE:\n                if len(scope) &lt; 1:\n                    raise ParseError(token.span, \"Mis-matched ']'!\")\n                scope.pop().add_op(RetOp())\n            elif token.kind in OPERATION_LOOKUP:\n                scope[-1].add_op(OPERATION_LOOKUP[token.kind]())\n            else:\n                raise ParseError(token.span, \"Unsupported token!\")\n\n        if len(scope) &gt; 1:\n            raise ParseError(token.span, \"Mis-matched '['!\")\n\n        return module_op\n</code></pre>"},{"location":"reference/frontend.html#xdslbf.frontend.parser.BrainFParser.__init__","title":"<code>__init__(file: Path, program: str)</code>","text":"<p>Instantiate the parser with the lexer.</p> Source code in <code>src/xdslbf/frontend/parser.py</code> <pre><code>def __init__(self, file: Path, program: str):\n    \"\"\"Instantiate the parser with the lexer.\"\"\"\n    super().__init__(ParserState(BrainFLexer(Input(program, str(file)))))\n</code></pre>"},{"location":"reference/frontend.html#xdslbf.frontend.parser.BrainFParser.parse","title":"<code>parse() -&gt; ModuleOp</code>","text":"<p>Parse a BrainF program.</p> Source code in <code>src/xdslbf/frontend/parser.py</code> <pre><code>def parse(self) -&gt; ModuleOp:\n    \"\"\"Parse a BrainF program.\"\"\"\n    module_op = ModuleOp([])\n    scope: list[Block] = [module_op.body.block]\n\n    while True:\n        token = self._consume_token()\n        if token.kind == BrainFTokenKind.EOF:\n            break\n\n        if token.kind == BrainFTokenKind.SBRACKET_OPEN:\n            scope[-1].add_op(LoopOp(regions=[Region([block := Block([])])]))\n            scope.append(block)\n        elif token.kind == BrainFTokenKind.SBRACKET_CLOSE:\n            if len(scope) &lt; 1:\n                raise ParseError(token.span, \"Mis-matched ']'!\")\n            scope.pop().add_op(RetOp())\n        elif token.kind in OPERATION_LOOKUP:\n            scope[-1].add_op(OPERATION_LOOKUP[token.kind]())\n        else:\n            raise ParseError(token.span, \"Unsupported token!\")\n\n    if len(scope) &gt; 1:\n        raise ParseError(token.span, \"Mis-matched '['!\")\n\n    return module_op\n</code></pre>"},{"location":"reference/interpreter.html","title":"Interpreter","text":""},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl","title":"<code>xdsl</code>","text":"<p>Interpreter using xDSL infrastructure for the BrainF language.</p>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions","title":"<code>BfFunctions</code>","text":"<p>               Bases: <code>InterpreterFunctions</code></p> <p>Interpreter implementations for the BrainF dialect.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@register_impls\nclass BfFunctions(InterpreterFunctions):\n    \"\"\"Interpreter implementations for the BrainF dialect.\"\"\"\n\n    @staticmethod\n    def set_state(interpreter: Interpreter, state: BfState) -&gt; None:\n        \"\"\"Set the initial BrainF mutable state.\"\"\"\n        interpreter.set_data(BfFunctions, \"bf_state\", state)\n\n    @staticmethod\n    def get_state(interpreter: Interpreter) -&gt; BfState:\n        \"\"\"Get the initial BrainF mutable state.\"\"\"\n        return interpreter.get_data(BfFunctions, \"bf_state\", BfState)\n\n    @impl(bf.IncOp)\n    def run_inc(\n        self, interpreter: Interpreter, _op: bf.IncOp, args: PythonValues\n    ) -&gt; PythonValues:\n        \"\"\"Interpret the increment operation in BrainF.\"\"\"\n        state = BfFunctions.get_state(interpreter)\n        state.memory[state.pointer] += 1\n        return args\n\n    @impl(bf.DecOp)\n    def run_dec(\n        self, interpreter: Interpreter, _op: bf.DecOp, args: PythonValues\n    ) -&gt; PythonValues:\n        \"\"\"Interpret the decrement operation in BrainF.\"\"\"\n        state = BfFunctions.get_state(interpreter)\n        state.memory[state.pointer] -= 1\n        return args\n\n    @impl(bf.LshftOp)\n    def run_lshft(\n        self, interpreter: Interpreter, _op: bf.LshftOp, args: PythonValues\n    ) -&gt; PythonValues:\n        \"\"\"Interpret the left shift operation in BrainF.\"\"\"\n        state = BfFunctions.get_state(interpreter)\n        state.pointer -= 1\n        if state.pointer &lt; 0:\n            raise PointerOutOfBoundsError(f\"Pointer value {state.pointer} &lt; 0\")\n        return args\n\n    @impl(bf.RshftOp)\n    def run_rshft(\n        self, interpreter: Interpreter, _op: bf.RshftOp, args: PythonValues\n    ) -&gt; PythonValues:\n        \"\"\"Interpret the right shift operation in BrainF.\"\"\"\n        state = BfFunctions.get_state(interpreter)\n        state.pointer += 1\n        if state.pointer &gt; len(state.memory):\n            raise PointerOutOfBoundsError(\n                f\"Pointer value {state.pointer} &lt; {len(state.memory)}\"\n            )\n        return args\n\n    @impl(bf.LoopOp)\n    def run_loop(\n        self, interpreter: Interpreter, op: bf.LoopOp, args: PythonValues\n    ) -&gt; PythonValues:\n        \"\"\"Interpret the loop operation in BrainF.\"\"\"\n        state = BfFunctions.get_state(interpreter)\n        while state.memory[state.pointer]:\n            assert len(op.regions) &gt; 0\n            args = interpreter.run_ssacfg_region(op.regions[0], args)\n        return args\n\n    @impl_terminator(bf.RetOp)\n    def run_ret(\n        self, _interpreter: Interpreter, _op: bf.RetOp, args: PythonValues\n    ) -&gt; PythonValues:\n        \"\"\"Interpret the return operation in BrainF.\"\"\"\n        return ReturnedValues(args), ()\n\n    @impl(bf.InOp)\n    def run_in(\n        self, interpreter: Interpreter, _op: bf.InOp, args: PythonValues\n    ) -&gt; PythonValues:\n        \"\"\"Interpret the input operation in BrainF.\"\"\"\n        state = BfFunctions.get_state(interpreter)\n        if state.input_stream is None:\n            state.memory[state.pointer] = ord(input(\"&gt; \")[0])\n        else:\n            state.memory[state.pointer] = ord(state.input_stream.read(1))\n        return args\n\n    @impl(bf.OutOp)\n    def run_out(\n        self, interpreter: Interpreter, _op: bf.OutOp, args: PythonValues\n    ) -&gt; PythonValues:\n        \"\"\"Interpret the output operation in BrainF.\"\"\"\n        state = BfFunctions.get_state(interpreter)\n        if state.output_stream is None:\n            print(chr(state.memory[state.pointer]), end=\"\")\n        else:\n            state.output_stream.write(chr(state.memory[state.pointer]))\n        return args\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions.set_state","title":"<code>set_state(interpreter: Interpreter, state: BfState) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Set the initial BrainF mutable state.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@staticmethod\ndef set_state(interpreter: Interpreter, state: BfState) -&gt; None:\n    \"\"\"Set the initial BrainF mutable state.\"\"\"\n    interpreter.set_data(BfFunctions, \"bf_state\", state)\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions.get_state","title":"<code>get_state(interpreter: Interpreter) -&gt; BfState</code>  <code>staticmethod</code>","text":"<p>Get the initial BrainF mutable state.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@staticmethod\ndef get_state(interpreter: Interpreter) -&gt; BfState:\n    \"\"\"Get the initial BrainF mutable state.\"\"\"\n    return interpreter.get_data(BfFunctions, \"bf_state\", BfState)\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions.run_inc","title":"<code>run_inc(interpreter: Interpreter, _op: bf.IncOp, args: PythonValues) -&gt; PythonValues</code>","text":"<p>Interpret the increment operation in BrainF.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@impl(bf.IncOp)\ndef run_inc(\n    self, interpreter: Interpreter, _op: bf.IncOp, args: PythonValues\n) -&gt; PythonValues:\n    \"\"\"Interpret the increment operation in BrainF.\"\"\"\n    state = BfFunctions.get_state(interpreter)\n    state.memory[state.pointer] += 1\n    return args\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions.run_dec","title":"<code>run_dec(interpreter: Interpreter, _op: bf.DecOp, args: PythonValues) -&gt; PythonValues</code>","text":"<p>Interpret the decrement operation in BrainF.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@impl(bf.DecOp)\ndef run_dec(\n    self, interpreter: Interpreter, _op: bf.DecOp, args: PythonValues\n) -&gt; PythonValues:\n    \"\"\"Interpret the decrement operation in BrainF.\"\"\"\n    state = BfFunctions.get_state(interpreter)\n    state.memory[state.pointer] -= 1\n    return args\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions.run_lshft","title":"<code>run_lshft(interpreter: Interpreter, _op: bf.LshftOp, args: PythonValues) -&gt; PythonValues</code>","text":"<p>Interpret the left shift operation in BrainF.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@impl(bf.LshftOp)\ndef run_lshft(\n    self, interpreter: Interpreter, _op: bf.LshftOp, args: PythonValues\n) -&gt; PythonValues:\n    \"\"\"Interpret the left shift operation in BrainF.\"\"\"\n    state = BfFunctions.get_state(interpreter)\n    state.pointer -= 1\n    if state.pointer &lt; 0:\n        raise PointerOutOfBoundsError(f\"Pointer value {state.pointer} &lt; 0\")\n    return args\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions.run_rshft","title":"<code>run_rshft(interpreter: Interpreter, _op: bf.RshftOp, args: PythonValues) -&gt; PythonValues</code>","text":"<p>Interpret the right shift operation in BrainF.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@impl(bf.RshftOp)\ndef run_rshft(\n    self, interpreter: Interpreter, _op: bf.RshftOp, args: PythonValues\n) -&gt; PythonValues:\n    \"\"\"Interpret the right shift operation in BrainF.\"\"\"\n    state = BfFunctions.get_state(interpreter)\n    state.pointer += 1\n    if state.pointer &gt; len(state.memory):\n        raise PointerOutOfBoundsError(\n            f\"Pointer value {state.pointer} &lt; {len(state.memory)}\"\n        )\n    return args\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions.run_loop","title":"<code>run_loop(interpreter: Interpreter, op: bf.LoopOp, args: PythonValues) -&gt; PythonValues</code>","text":"<p>Interpret the loop operation in BrainF.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@impl(bf.LoopOp)\ndef run_loop(\n    self, interpreter: Interpreter, op: bf.LoopOp, args: PythonValues\n) -&gt; PythonValues:\n    \"\"\"Interpret the loop operation in BrainF.\"\"\"\n    state = BfFunctions.get_state(interpreter)\n    while state.memory[state.pointer]:\n        assert len(op.regions) &gt; 0\n        args = interpreter.run_ssacfg_region(op.regions[0], args)\n    return args\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions.run_ret","title":"<code>run_ret(_interpreter: Interpreter, _op: bf.RetOp, args: PythonValues) -&gt; PythonValues</code>","text":"<p>Interpret the return operation in BrainF.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@impl_terminator(bf.RetOp)\ndef run_ret(\n    self, _interpreter: Interpreter, _op: bf.RetOp, args: PythonValues\n) -&gt; PythonValues:\n    \"\"\"Interpret the return operation in BrainF.\"\"\"\n    return ReturnedValues(args), ()\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions.run_in","title":"<code>run_in(interpreter: Interpreter, _op: bf.InOp, args: PythonValues) -&gt; PythonValues</code>","text":"<p>Interpret the input operation in BrainF.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@impl(bf.InOp)\ndef run_in(\n    self, interpreter: Interpreter, _op: bf.InOp, args: PythonValues\n) -&gt; PythonValues:\n    \"\"\"Interpret the input operation in BrainF.\"\"\"\n    state = BfFunctions.get_state(interpreter)\n    if state.input_stream is None:\n        state.memory[state.pointer] = ord(input(\"&gt; \")[0])\n    else:\n        state.memory[state.pointer] = ord(state.input_stream.read(1))\n    return args\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BfFunctions.run_out","title":"<code>run_out(interpreter: Interpreter, _op: bf.OutOp, args: PythonValues) -&gt; PythonValues</code>","text":"<p>Interpret the output operation in BrainF.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@impl(bf.OutOp)\ndef run_out(\n    self, interpreter: Interpreter, _op: bf.OutOp, args: PythonValues\n) -&gt; PythonValues:\n    \"\"\"Interpret the output operation in BrainF.\"\"\"\n    state = BfFunctions.get_state(interpreter)\n    if state.output_stream is None:\n        print(chr(state.memory[state.pointer]), end=\"\")\n    else:\n        state.output_stream.write(chr(state.memory[state.pointer]))\n    return args\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BrainFInterpreter","title":"<code>BrainFInterpreter</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBrainFInterpreter</code></p> <p>xDSL-based interpreter for the BrainF language.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>@dataclass\nclass BrainFInterpreter(BaseBrainFInterpreter):\n    \"\"\"xDSL-based interpreter for the BrainF language.\"\"\"\n\n    state: BfState = field(default_factory=BfState)\n\n    def interpret(self, program: ModuleOp) -&gt; None:\n        \"\"\"Interpret a BrainF program using xDSL infrastructure.\"\"\"\n        interpreter = Interpreter(program)\n        interpreter.register_implementations(BfFunctions())\n        BfFunctions.set_state(interpreter, self.state)\n\n        interpreter.run_ssacfg_region(program.body, ())\n\n        if (out := self.state.output_stream) is not None:\n            print(out)\n        else:\n            print()\n\n    @property\n    def output(self) -&gt; str:\n        \"\"\"Get the string value of the output stream.\"\"\"\n        assert isinstance(self.state.output_stream, StringIO)\n        return self.state.output_stream.getvalue()\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BrainFInterpreter.output","title":"<code>output: str</code>  <code>property</code>","text":"<p>Get the string value of the output stream.</p>"},{"location":"reference/interpreter.html#xdslbf.interpreters.xdsl.BrainFInterpreter.interpret","title":"<code>interpret(program: ModuleOp) -&gt; None</code>","text":"<p>Interpret a BrainF program using xDSL infrastructure.</p> Source code in <code>src/xdslbf/interpreters/xdsl.py</code> <pre><code>def interpret(self, program: ModuleOp) -&gt; None:\n    \"\"\"Interpret a BrainF program using xDSL infrastructure.\"\"\"\n    interpreter = Interpreter(program)\n    interpreter.register_implementations(BfFunctions())\n    BfFunctions.set_state(interpreter, self.state)\n\n    interpreter.run_ssacfg_region(program.body, ())\n\n    if (out := self.state.output_stream) is not None:\n        print(out)\n    else:\n        print()\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.base","title":"<code>base</code>","text":"<p>Implementations of mutable state for the BrainF interpreters.</p>"},{"location":"reference/interpreter.html#xdslbf.interpreters.base.PointerOutOfBoundsError","title":"<code>PointerOutOfBoundsError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Exception to indicate the pointer is outside the memory tape.</p> Source code in <code>src/xdslbf/interpreters/base.py</code> <pre><code>class PointerOutOfBoundsError(RuntimeError):\n    \"\"\"Exception to indicate the pointer is outside the memory tape.\"\"\"\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.base.BfState","title":"<code>BfState</code>  <code>dataclass</code>","text":"<p>A representation of BrainF mutable state.</p> Source code in <code>src/xdslbf/interpreters/base.py</code> <pre><code>@dataclass\nclass BfState:\n    \"\"\"A representation of BrainF mutable state.\"\"\"\n\n    pointer: int = 0\n    memory: list[int] = field(default_factory=lambda: [0] * 30_000)\n    input_stream: TextIO | None = None\n    output_stream: TextIO | None = None\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.base.BaseBrainFInterpreter","title":"<code>BaseBrainFInterpreter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Interpreter for the BrainF language.</p> Source code in <code>src/xdslbf/interpreters/base.py</code> <pre><code>class BaseBrainFInterpreter(abc.ABC):\n    \"\"\"Interpreter for the BrainF language.\"\"\"\n\n    @abc.abstractmethod\n    def interpret(self, program: ModuleOp) -&gt; None:\n        \"\"\"Interpret a BrainF program.\"\"\"\n        ...\n\n    @property\n    @abc.abstractmethod\n    def output(self) -&gt; str:\n        \"\"\"Get the string value of the output stream.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/interpreter.html#xdslbf.interpreters.base.BaseBrainFInterpreter.output","title":"<code>output: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the string value of the output stream.</p>"},{"location":"reference/interpreter.html#xdslbf.interpreters.base.BaseBrainFInterpreter.interpret","title":"<code>interpret(program: ModuleOp) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Interpret a BrainF program.</p> Source code in <code>src/xdslbf/interpreters/base.py</code> <pre><code>@abc.abstractmethod\ndef interpret(self, program: ModuleOp) -&gt; None:\n    \"\"\"Interpret a BrainF program.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/transforms.html","title":"Transforms","text":""},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin","title":"<code>lower_bf_builtin</code>","text":"<p>A pass which lowers the bf dialect to use only builtin mlir dialects.</p>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.ShiftOpLowering","title":"<code>ShiftOpLowering</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewritePattern</code></p> <p>A pattern to rewrite left and right shift operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@dataclass\nclass ShiftOpLowering(RewritePattern):\n    \"\"\"A pattern to rewrite left and right shift operations.\"\"\"\n\n    data_pointer: memref.AllocaOp\n\n    @op_type_rewrite_pattern\n    def match_and_rewrite(\n        self, op: bf.LshftOp | bf.RshftOp, rewriter: PatternRewriter\n    ) -&gt; None:\n        \"\"\"Rewrite left and right shift operations.\"\"\"\n        arith_op = arith.AddiOp if isinstance(op, bf.RshftOp) else arith.SubiOp\n        rewriter.replace_op(\n            op,\n            [\n                load_op := memref.LoadOp.get(self.data_pointer, []),\n                const_1 := arith.ConstantOp.from_int_and_width(1, i32),\n                inc_op := arith_op(load_op, const_1),\n                memref.StoreOp.get(inc_op, self.data_pointer, []),\n            ],\n        )\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.ShiftOpLowering.match_and_rewrite","title":"<code>match_and_rewrite(op: bf.LshftOp | bf.RshftOp, rewriter: PatternRewriter) -&gt; None</code>","text":"<p>Rewrite left and right shift operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@op_type_rewrite_pattern\ndef match_and_rewrite(\n    self, op: bf.LshftOp | bf.RshftOp, rewriter: PatternRewriter\n) -&gt; None:\n    \"\"\"Rewrite left and right shift operations.\"\"\"\n    arith_op = arith.AddiOp if isinstance(op, bf.RshftOp) else arith.SubiOp\n    rewriter.replace_op(\n        op,\n        [\n            load_op := memref.LoadOp.get(self.data_pointer, []),\n            const_1 := arith.ConstantOp.from_int_and_width(1, i32),\n            inc_op := arith_op(load_op, const_1),\n            memref.StoreOp.get(inc_op, self.data_pointer, []),\n        ],\n    )\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.IncOpLowering","title":"<code>IncOpLowering</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewritePattern</code></p> <p>A pattern to rewrite increment and decrement operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@dataclass\nclass IncOpLowering(RewritePattern):\n    \"\"\"A pattern to rewrite increment and decrement operations.\"\"\"\n\n    data_pointer: memref.AllocaOp\n    memory: memref.AllocOp\n\n    @op_type_rewrite_pattern\n    def match_and_rewrite(\n        self, op: bf.IncOp | bf.DecOp, rewriter: PatternRewriter\n    ) -&gt; None:\n        \"\"\"Rewrite increment and decrement operations.\"\"\"\n        arith_op = arith.AddiOp if isinstance(op, bf.IncOp) else arith.SubiOp\n        rewriter.replace_op(\n            op,\n            [\n                load_pointer_op := memref.LoadOp.get(self.data_pointer, []),\n                pointer_index := arith.IndexCastOp(load_pointer_op, IndexType()),\n                load_data_op := memref.LoadOp.get(self.memory, [pointer_index]),\n                const_1 := arith.ConstantOp.from_int_and_width(1, i32),\n                inc_op := arith_op(load_data_op, const_1),\n                memref.StoreOp.get(inc_op, self.memory, [pointer_index]),\n            ],\n        )\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.IncOpLowering.match_and_rewrite","title":"<code>match_and_rewrite(op: bf.IncOp | bf.DecOp, rewriter: PatternRewriter) -&gt; None</code>","text":"<p>Rewrite increment and decrement operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@op_type_rewrite_pattern\ndef match_and_rewrite(\n    self, op: bf.IncOp | bf.DecOp, rewriter: PatternRewriter\n) -&gt; None:\n    \"\"\"Rewrite increment and decrement operations.\"\"\"\n    arith_op = arith.AddiOp if isinstance(op, bf.IncOp) else arith.SubiOp\n    rewriter.replace_op(\n        op,\n        [\n            load_pointer_op := memref.LoadOp.get(self.data_pointer, []),\n            pointer_index := arith.IndexCastOp(load_pointer_op, IndexType()),\n            load_data_op := memref.LoadOp.get(self.memory, [pointer_index]),\n            const_1 := arith.ConstantOp.from_int_and_width(1, i32),\n            inc_op := arith_op(load_data_op, const_1),\n            memref.StoreOp.get(inc_op, self.memory, [pointer_index]),\n        ],\n    )\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.LoopOpLowering","title":"<code>LoopOpLowering</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewritePattern</code></p> <p>A pattern to rewrite loop operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@dataclass\nclass LoopOpLowering(RewritePattern):\n    \"\"\"A pattern to rewrite loop operations.\"\"\"\n\n    data_pointer: memref.AllocaOp\n    memory: memref.AllocOp\n\n    @op_type_rewrite_pattern\n    def match_and_rewrite(self, op: bf.LoopOp, rewriter: PatternRewriter) -&gt; None:\n        \"\"\"Rewrite loop operations.\"\"\"\n        # Extract and detach the body of the `bf.loop` operation\n        op.detach_region(loop_body := op.regions[0])\n\n        # Construct a while loop with the `bf.loop`'s body\n        while_loop = scf.WhileOp(\n            arguments=[],\n            result_types=[],\n            before_region=[\n                Block(\n                    [\n                        load_pointer_op := memref.LoadOp.get(self.data_pointer, []),\n                        pointer_index := arith.IndexCastOp(\n                            load_pointer_op, IndexType()\n                        ),\n                        load_data_op := memref.LoadOp.get(self.memory, [pointer_index]),\n                        const_0 := arith.ConstantOp.from_int_and_width(0, i32),\n                        cmp_op := arith.CmpiOp(load_data_op, const_0, \"ne\"),\n                        scf.ConditionOp(cmp_op),\n                    ]\n                )\n            ],\n            after_region=loop_body,\n        )\n\n        # Replace the matched operation with the newly constructed while loop\n        rewriter.replace_matched_op(while_loop)\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.LoopOpLowering.match_and_rewrite","title":"<code>match_and_rewrite(op: bf.LoopOp, rewriter: PatternRewriter) -&gt; None</code>","text":"<p>Rewrite loop operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@op_type_rewrite_pattern\ndef match_and_rewrite(self, op: bf.LoopOp, rewriter: PatternRewriter) -&gt; None:\n    \"\"\"Rewrite loop operations.\"\"\"\n    # Extract and detach the body of the `bf.loop` operation\n    op.detach_region(loop_body := op.regions[0])\n\n    # Construct a while loop with the `bf.loop`'s body\n    while_loop = scf.WhileOp(\n        arguments=[],\n        result_types=[],\n        before_region=[\n            Block(\n                [\n                    load_pointer_op := memref.LoadOp.get(self.data_pointer, []),\n                    pointer_index := arith.IndexCastOp(\n                        load_pointer_op, IndexType()\n                    ),\n                    load_data_op := memref.LoadOp.get(self.memory, [pointer_index]),\n                    const_0 := arith.ConstantOp.from_int_and_width(0, i32),\n                    cmp_op := arith.CmpiOp(load_data_op, const_0, \"ne\"),\n                    scf.ConditionOp(cmp_op),\n                ]\n            )\n        ],\n        after_region=loop_body,\n    )\n\n    # Replace the matched operation with the newly constructed while loop\n    rewriter.replace_matched_op(while_loop)\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.RetOpLowering","title":"<code>RetOpLowering</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewritePattern</code></p> <p>A pattern to rewrite return operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@dataclass\nclass RetOpLowering(RewritePattern):\n    \"\"\"A pattern to rewrite return operations.\"\"\"\n\n    @op_type_rewrite_pattern\n    def match_and_rewrite(self, op: bf.RetOp, rewriter: PatternRewriter) -&gt; None:\n        \"\"\"Rewrite ret operations.\"\"\"\n        rewriter.replace_op(op, scf.YieldOp())\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.RetOpLowering.match_and_rewrite","title":"<code>match_and_rewrite(op: bf.RetOp, rewriter: PatternRewriter) -&gt; None</code>","text":"<p>Rewrite ret operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@op_type_rewrite_pattern\ndef match_and_rewrite(self, op: bf.RetOp, rewriter: PatternRewriter) -&gt; None:\n    \"\"\"Rewrite ret operations.\"\"\"\n    rewriter.replace_op(op, scf.YieldOp())\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.OutOpLowering","title":"<code>OutOpLowering</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewritePattern</code></p> <p>A pattern to rewrite output operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@dataclass\nclass OutOpLowering(RewritePattern):\n    \"\"\"A pattern to rewrite output operations.\"\"\"\n\n    data_pointer: memref.AllocaOp\n    memory: memref.AllocOp\n\n    @op_type_rewrite_pattern\n    def match_and_rewrite(self, op: bf.OutOp, rewriter: PatternRewriter) -&gt; None:\n        \"\"\"Rewrite output operations.\"\"\"\n        rewriter.insert_op_before_matched_op(\n            [\n                load_pointer_op := memref.LoadOp.get(self.data_pointer, []),\n                pointer_index := arith.IndexCastOp(load_pointer_op, IndexType()),\n                load_data_op := memref.LoadOp.get(self.memory, [pointer_index]),\n                func.CallOp(\"putchar\", [load_data_op], [i32]),\n            ]\n        )\n        rewriter.erase_op(op)\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.OutOpLowering.match_and_rewrite","title":"<code>match_and_rewrite(op: bf.OutOp, rewriter: PatternRewriter) -&gt; None</code>","text":"<p>Rewrite output operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@op_type_rewrite_pattern\ndef match_and_rewrite(self, op: bf.OutOp, rewriter: PatternRewriter) -&gt; None:\n    \"\"\"Rewrite output operations.\"\"\"\n    rewriter.insert_op_before_matched_op(\n        [\n            load_pointer_op := memref.LoadOp.get(self.data_pointer, []),\n            pointer_index := arith.IndexCastOp(load_pointer_op, IndexType()),\n            load_data_op := memref.LoadOp.get(self.memory, [pointer_index]),\n            func.CallOp(\"putchar\", [load_data_op], [i32]),\n        ]\n    )\n    rewriter.erase_op(op)\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.InOpLowering","title":"<code>InOpLowering</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewritePattern</code></p> <p>A pattern to rewrite input operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@dataclass\nclass InOpLowering(RewritePattern):\n    \"\"\"A pattern to rewrite input operations.\"\"\"\n\n    data_pointer: memref.AllocaOp\n    memory: memref.AllocOp\n\n    @op_type_rewrite_pattern\n    def match_and_rewrite(self, op: bf.InOp, rewriter: PatternRewriter) -&gt; None:\n        \"\"\"Rewrite input operations.\"\"\"\n        rewriter.insert_op_before_matched_op(\n            [\n                data := func.CallOp(\"getchar\", [], [i32]),\n                load_pointer_op := memref.LoadOp.get(self.data_pointer, []),\n                pointer_index := arith.IndexCastOp(load_pointer_op, IndexType()),\n                memref.StoreOp.get(data, self.memory, [pointer_index]),\n            ]\n        )\n        rewriter.erase_op(op)\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.InOpLowering.match_and_rewrite","title":"<code>match_and_rewrite(op: bf.InOp, rewriter: PatternRewriter) -&gt; None</code>","text":"<p>Rewrite input operations.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>@op_type_rewrite_pattern\ndef match_and_rewrite(self, op: bf.InOp, rewriter: PatternRewriter) -&gt; None:\n    \"\"\"Rewrite input operations.\"\"\"\n    rewriter.insert_op_before_matched_op(\n        [\n            data := func.CallOp(\"getchar\", [], [i32]),\n            load_pointer_op := memref.LoadOp.get(self.data_pointer, []),\n            pointer_index := arith.IndexCastOp(load_pointer_op, IndexType()),\n            memref.StoreOp.get(data, self.memory, [pointer_index]),\n        ]\n    )\n    rewriter.erase_op(op)\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.LowerBfToBuiltinPass","title":"<code>LowerBfToBuiltinPass</code>","text":"<p>               Bases: <code>ModulePass</code></p> <p>A pass for lowering operations in the bf dialect to only use builtin dialects.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>class LowerBfToBuiltinPass(ModulePass):\n    \"\"\"A pass for lowering operations in the bf dialect to only use builtin dialects.\"\"\"\n\n    name = \"bf-to-builtin\"\n\n    def build_brainf_environment(\n        self, _ctx: Context, op: ModuleOp, memory_size: int = 30_000\n    ) -&gt; tuple[memref.AllocaOp, memref.AllocOp]:\n        \"\"\"Build the brainf environment.\n\n        This includes allocating the data pointer and the memory region.\n        \"\"\"\n        # Lift the ir into a main function\n        op.detach_region(region := op.body)\n        block = region.block\n        op.add_region(\n            Region(\n                outer_block := Block([func.FuncOp(\"main\", ((), (i32,)), region=region)])\n            )\n        )\n\n        # Instantiate the operations to register IO functions\n        setup: list[Operation] = [\n            func.FuncOp.external(\"putchar\", (i32,), (i32,)),\n            func.FuncOp.external(\"getchar\", (), (i32,)),\n        ]\n        assert outer_block.first_op is not None\n        for new_op in setup:\n            outer_block.insert_op_before(new_op, outer_block.first_op)\n\n        # Instantiate the operations setting up the runtime\n        setup: list[Operation] = [\n            const_0 := arith.ConstantOp.from_int_and_width(0, i32),\n            data_pointer_alloca_op := memref.AllocaOp.get(i32, 64, []),\n            memref.StoreOp.get(const_0, data_pointer_alloca_op, []),\n            memory_alloc_op := memref.AllocOp.get(i32, 64, [memory_size]),\n        ]\n        first_op = block.first_op\n        if first_op is not None:\n            block.insert_ops_before(setup, first_op)\n        else:\n            block.add_ops(setup)\n\n        # Instantiate the operations tearing down up the runtime\n        block.add_ops(\n            [\n                memref.DeallocOp.get(memory_alloc_op),\n                func.ReturnOp(const_0),\n            ]\n        )\n\n        # Return SSA references to operations used by the lowering passes\n        return (data_pointer_alloca_op, memory_alloc_op)\n\n    def apply(self, ctx: Context, op: ModuleOp) -&gt; None:\n        \"\"\"Apply the lowering pass.\"\"\"\n        data_pointer, memory = self.build_brainf_environment(ctx, op)\n        PatternRewriteWalker(\n            GreedyRewritePatternApplier(\n                [\n                    ShiftOpLowering(data_pointer),\n                    IncOpLowering(data_pointer, memory),\n                    LoopOpLowering(data_pointer, memory),\n                    RetOpLowering(),\n                    InOpLowering(data_pointer, memory),\n                    OutOpLowering(data_pointer, memory),\n                ]\n            )\n        ).rewrite_module(op)\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.LowerBfToBuiltinPass.build_brainf_environment","title":"<code>build_brainf_environment(_ctx: Context, op: ModuleOp, memory_size: int = 30000) -&gt; tuple[memref.AllocaOp, memref.AllocOp]</code>","text":"<p>Build the brainf environment.</p> <p>This includes allocating the data pointer and the memory region.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>def build_brainf_environment(\n    self, _ctx: Context, op: ModuleOp, memory_size: int = 30_000\n) -&gt; tuple[memref.AllocaOp, memref.AllocOp]:\n    \"\"\"Build the brainf environment.\n\n    This includes allocating the data pointer and the memory region.\n    \"\"\"\n    # Lift the ir into a main function\n    op.detach_region(region := op.body)\n    block = region.block\n    op.add_region(\n        Region(\n            outer_block := Block([func.FuncOp(\"main\", ((), (i32,)), region=region)])\n        )\n    )\n\n    # Instantiate the operations to register IO functions\n    setup: list[Operation] = [\n        func.FuncOp.external(\"putchar\", (i32,), (i32,)),\n        func.FuncOp.external(\"getchar\", (), (i32,)),\n    ]\n    assert outer_block.first_op is not None\n    for new_op in setup:\n        outer_block.insert_op_before(new_op, outer_block.first_op)\n\n    # Instantiate the operations setting up the runtime\n    setup: list[Operation] = [\n        const_0 := arith.ConstantOp.from_int_and_width(0, i32),\n        data_pointer_alloca_op := memref.AllocaOp.get(i32, 64, []),\n        memref.StoreOp.get(const_0, data_pointer_alloca_op, []),\n        memory_alloc_op := memref.AllocOp.get(i32, 64, [memory_size]),\n    ]\n    first_op = block.first_op\n    if first_op is not None:\n        block.insert_ops_before(setup, first_op)\n    else:\n        block.add_ops(setup)\n\n    # Instantiate the operations tearing down up the runtime\n    block.add_ops(\n        [\n            memref.DeallocOp.get(memory_alloc_op),\n            func.ReturnOp(const_0),\n        ]\n    )\n\n    # Return SSA references to operations used by the lowering passes\n    return (data_pointer_alloca_op, memory_alloc_op)\n</code></pre>"},{"location":"reference/transforms.html#xdslbf.transforms.lower_bf_builtin.LowerBfToBuiltinPass.apply","title":"<code>apply(ctx: Context, op: ModuleOp) -&gt; None</code>","text":"<p>Apply the lowering pass.</p> Source code in <code>src/xdslbf/transforms/lower_bf_builtin.py</code> <pre><code>def apply(self, ctx: Context, op: ModuleOp) -&gt; None:\n    \"\"\"Apply the lowering pass.\"\"\"\n    data_pointer, memory = self.build_brainf_environment(ctx, op)\n    PatternRewriteWalker(\n        GreedyRewritePatternApplier(\n            [\n                ShiftOpLowering(data_pointer),\n                IncOpLowering(data_pointer, memory),\n                LoopOpLowering(data_pointer, memory),\n                RetOpLowering(),\n                InOpLowering(data_pointer, memory),\n                OutOpLowering(data_pointer, memory),\n            ]\n        )\n    ).rewrite_module(op)\n</code></pre>"},{"location":"tutorial/1_intro.html","title":"Compiling BrainF with Python and LLVM, Fast -- Part 1: Introduction","text":""},{"location":"tutorial/1_intro.html#compiling-brainf-with-python-and-llvm-fast-part-1-introduction","title":"Compiling BrainF with Python and LLVM, Fast -- Part 1: Introduction\u00b6","text":""},{"location":"tutorial/1_intro.html#building-a-compiler-fast","title":"Building a compiler, fast\u00b6","text":"<p>\"Give me six hours to chop down a tree and I will spend the first four sharpening the axe\"</p> <p>\u2014 commonly misattributed to Abraham Lincoln</p>"},{"location":"tutorial/1_intro.html#mlir","title":"MLIR\u00b6","text":""},{"location":"tutorial/1_intro.html#xdsl","title":"xDSL\u00b6","text":""},{"location":"tutorial/1_intro.html#brainf","title":"BrainF\u00b6","text":"<p>This blog post series focusses on the popular esoteric language we refer to as \"BrainF to cater to the whims of modern SEO.</p> <p>BrainF is interesting as it has a very short instruction set whilst still being Turing complete [^]. This short instruction set makes it difficult to write complex programs, but easy to write a correct compiler for it, having a trivial grammar and simple semantics, shown below:</p>"},{"location":"tutorial/2_dialects.html","title":"Compiling BrainF with Python and LLVM, Fast -- Part 2: Dialects","text":""},{"location":"tutorial/2_dialects.html#compiling-brainf-with-python-and-llvm-fast-part-2-dialects","title":"Compiling BrainF with Python and LLVM, Fast -- Part 2: Dialects\u00b6","text":""},{"location":"tutorial/3_parser.html","title":"Compiling BrainF with Python and LLVM, Fast -- Part 3: Parsing","text":""},{"location":"tutorial/3_parser.html#compiling-brainf-with-python-and-llvm-fast-part-3-parsing","title":"Compiling BrainF with Python and LLVM, Fast -- Part 3: Parsing\u00b6","text":""},{"location":"tutorial/4_interpreter.html","title":"Compiling BrainF with Python and LLVM, Fast -- Part 4: Interpreting","text":""},{"location":"tutorial/4_interpreter.html#compiling-brainf-with-python-and-llvm-fast-part-4-interpreting","title":"Compiling BrainF with Python and LLVM, Fast -- Part 4: Interpreting\u00b6","text":""},{"location":"tutorial/5_lowering.html","title":"Compiling BrainF with Python and LLVM, Fast -- Part 5: Lowering","text":""},{"location":"tutorial/5_lowering.html#compiling-brainf-with-python-and-llvm-fast-part-5-lowering","title":"Compiling BrainF with Python and LLVM, Fast -- Part 5: Lowering\u00b6","text":""},{"location":"tutorial/6_optimisations.html","title":"Compiling BrainF with Python and LLVM, Fast -- Part 6: Optimisations","text":""},{"location":"tutorial/6_optimisations.html#compiling-brainf-with-python-and-llvm-fast-part-6-optimisations","title":"Compiling BrainF with Python and LLVM, Fast -- Part 6: Optimisations\u00b6","text":""}]}